# JAVA基础

## 基础

#### Java中有全局变量吗



#### final关键字，final修饰的方法不能被重写，能被重载吗？

（在这里额外提了Java内存模型对于final的底层实现）



#### String 基本类型的转换



#### static



#### Java 里面的 clone



#### 接口和抽象类



#### string，stringbuilder，stringbuffer比较

## 集合

#### lambda对Java到底是好是坏



#### Java map底层实现



#### HashMap



#### ConcurrentHashMap



### hashtable



#### 散列表（哈希表）





## Gc

### 概念

#### 什么时候会导致垃圾回收

1. 排查内存溢出
2. 排查内存泄漏
3. 性能调优，排查并发瓶颈

> **GC**目的：回收堆内存中不再使用的对象，释放资源
>  回收时间：当对象永久地失去引用后，系统会在合适的时候回收它所占的内存。
>
> 另一种更详细一点**GC**时间的说法就是：
>  1、当应用程序分配新的对象，GC的代的预算大小已经达到阈值，比如GC的第0代已满
>  2、代码主动显式调用System.GC.Collect()
>  3、其他特殊情况，比如，windows报告内存不足、CLR卸载AppDomain、CLR关闭，甚至某些极端情况下系统参数设置改变也可能导致GC回收

#### Gc是怎么运行的

1. 标记
2. 计划 
3. 清理

#### 新老以及永久区是什么

新区和老区指的是java堆

java堆被分为新生代和老年代。新生代又被分为一个**Eden**和两个**Survivor**，一个**From Survivor**、一个**To Survivor ****(复制算法)**

永久区用来存放方法区（存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息）

#### Gc 有几种方式？怎么配置？

##### Gc算法

1. 标记-清除
2. 复制
3. 标记-整理

##### 收集器

1. Serial
2. ParNew
3. Parallel Scavenge
4. CMS
5. G1

#### 什么时候一个对象会被GC？如何判断一个对象是否存活?

1. 引用计数法

   在对象上添加一个引用计数器，每当有一个对象引用它时，计数器加1，当使用完该对象时，计数器减1，计数器值为0的对象表示不可能再被使用。引用计数法实现简单，判定高效，但不能解决对象之间相互引用的问题

2. 可达性分析法

   通过一系列称为 “GC Roots” 的所有对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链”。

   以下对象可作为GC Roots：

   1. 本地变量表中引用的对象(栈)
   2. 方法区中静态变量引用的对象
   3. 方法区中常量引用的对象
   4. Native方法引用的对象

#### System.gc() Runtime.gc()会做什么事情？能保证 GC 执行吗？

两者基本无区别 知识Runtime.gc()需要一个instance

不会当你调用System.gc()就会进行gc

程序员可以手动执行`System.gc()`，通知GC运行，但是Java语言规范并不保证GC一定会执行

#### Minor GC 、Major GC、Young GC 与 Full GC分别在什么时候发生?

* Minor Gc 指的是新生代的垃圾收集操作，所有Minor Gc都会暂停应用程序的线程

  > 新生代通常存活时间较短基于Copying算法进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和FromSpace或ToSpace之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从Eden到Survivor，最后到老年代。

* Major GC 指的是老年代的垃圾收集操作

  > 老年代与新生代不同，老年代对象存活的时间比较长、比较稳定，因此采用标记(Mark)算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并、要么标记出来便于下次进行分配，总之目的就是要减少内存碎片带来的效率损耗和大对象无法存储

#### 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？

不会，会等到下一个垃圾回收周期



#### JVM的永久代中会发生垃圾回收吗

> 很多人认为方法区 (或者 HotSpot 虚拟机中的永久代) 是没有垃圾收集的，但是并不是没有，只是在方法区中进行垃圾收集的“性价比”一般比较低 ，而在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。
>
> **永久代的垃圾收集主要回收两部分内容 : 废弃常量和无用的类**。回收废弃常量与回收Java 堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String 对象是叫做“abc”的，换句话说，就是没有任何 String 对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量地。常量池中的其他类(接口)、方法、字段的符号引用也与此类似。判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是"无用的类":
>
> - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
> - 加载该类的 ClassLoader 已经被回收。
> - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
>
> 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以” 。而并不是和对象一样，不使用了就必然会回收。
>
> 是否对类进行回收，HotSpot 虚拟机提供了 `-Xnoclassgc` 参数进行控制，还可以使用 `-verbose:class` 以及 `-XX:HTraceClassLoading`、`-XX:HTraceClassUnLoading` 查看类加载和印载信息。

### Gc收集器

#### 垃圾回收器的基本原理是什么？

垃圾回收器是一个级别很低的守护线程,它通过不定时监测程序使用的内存中被占用的动态分配的内存内的对象是否还存在它的引用来判断是否该回收那个内存单元,如果不存在则回收,否则相反~~并不是只要监测到就会回收的,因为垃圾回收器线程的低级别,所以当另一个级别比它高的线程跟他同时竞争运行时间时,前者优先运行,所以你无法知道垃圾回收器何时回收,System.gc()只是建议垃圾回收器进行回收处理,调用它并不能保证它回立即回收。

#### Serial 与 Parallel GC之间的不同之处

| Serial             | Parallel GC                      |
| ------------------ | -------------------------------- |
| 注重低停顿时间     | 注重CPU效率                      |
| 单线程             | 多线程并行                       |
| 多用于client机器上 | 在后台运算而不需要太多的交互任务 |

#### CMS 收集器 与 G1 收集器的特点与区别



#### 吞吐量优先和响应优先的垃圾收集器选择？选择一个GC策略？

和用户交互比较多的遵循响应优先，提高用户体验。

吞吐量则可以高效率地利用CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务



## JVM

### 参数

#### 说说你知道的几种主要的jvm 参数

* -XX:MaxGCPauseMills 
  * 最大停顿时间 
  * 单位毫秒

* -XX:GCTimeRatio 
  * 0-100的取值范围
  * 垃圾收集时间占总时间的比
  * 默认99，即最大允许1%时间做GC
  * 计算吞吐量
* -XX:ParallelGCThreads=8
  * Gc并行线程数
* -XX:SurvivorRatio=8
  * 新生代中 Surviver和Eden的比例
* -XX:+DisableExplicitGC
  * 不允许显示调用System.gc()

> 推荐文章  <https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html>

> ```
> -server -Xmx3g -Xms3g -XX:MaxPermSize=128m 
> -XX:NewRatio=1  eden/old 的比例
> -XX:SurvivorRatio=8  s/e的比例 
> -XX:+UseParallelGC 
> -XX:ParallelGCThreads=8  
> -XX:+UseParallelOldGC  这个是JAVA 6出现的参数选项 
> -XX:LargePageSizeInBytes=128m 内存页的大小， 不可设置过大， 会影响Perm的大小。 
> -XX:+UseFastAccessorMethods 原始类型的快速优化 
> -XX:+DisableExplicitGC  关闭System.gc()
> ```

### 类加载器

#### 双亲委派模型



### 内存管理

#### java的几种引用



#### JVM中锁优化，偏向锁、自旋锁、锁消除、锁膨胀

### JVM调优



## 多线程

#### 10个线程执行，然后主线程必须等10个线程都执行完了，然后获取到10个线程的计算结果，然后才能计算出自己的结果，也就是说必须等待10个线程都执行完了，我才执行，如何做？

我说了Thread.join(),等待执行；然后就是callable 与FutureTask结合执行，通过FutureTask去获取线程的执行状态，写一个while循环一直去查询；另一种我说了使用CountDownLatch;

### 进程通信



#### Synchronize可以用什么代替



#### Java里synchronized是怎么实现的？synchronized是可重入锁吗，怎么实现？



#### OS进程间通信的方式？Java使用的哪种方式？



#### 介绍一下Java中的锁？可重入锁如何实现的可重入？



## Spring

#### Spring源码中的设计模式



#### bean循环依赖怎么解决



#### 为什么要用Spring Boot的Starter ，而不是和普通的maven一样导入

可以认为starter是一种服务（和JS的插件类似）——使得使用某个功能的开发者不需要关注各种依赖库的处理，不需要具体的配置信息，由Spring Boot自动通过classpath路径下的类发现需要的Bean，并织入bean

个人理解 大概就是通过SpringBoot的自动配置功能简化配置



#### Spring管理的bean的对象存储在哪里。

类的元信息比如常量表，字面量，静态字段在方法区（Method Area里），关于对象的数据在jvm堆里。



#### IOC, AOP，IOC（控制反转）和DI（依赖注入）有什么不同，Java反射机制。



#### spring事务传播行为（擦当时一激动忘的透彻就说了Spring有7种），默认是选择哪一种，为什么要有传播行为。



#### bean生命周期



#### spring加载过程

## 微服务



## 消息队列

# 算法

#### 如何设计一个LRU，用什么数据结构，以及set，get的O(1)的时间复杂度如何实现

<https://www.nowcoder.com/discuss/192422>

#### 单链表翻转（递归、循环）



#### 算法的时间复杂度和空间复杂度的含义，分析一下快排的？

#### 

#### Top K问题



#### AES和RSA实现原理



#### 锦标赛排序



#### 01背包



#### kmp算法

# 计算机网络

## 基础知识

#### 计算机网络模型有哪些，分别介绍

#### 当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤

域名解析--> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求--> 浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户

## 应用层协议

### http1.0、http1.1和http2.0区别

| http1.0 |               无状态 无连接               |
| :-----: | :---------------------------------------: |
| http1.1 |                 持久连接                  |
|         |                请求管道化                 |
|         | 增加缓存处理（新的字段如`cache-control`） |
|         |              增加`Host`字段               |
|         |    支持断点传输等（把文件分成几部分）     |
| http2.0 |                二进制分帧                 |
|         |          多路复用（或连接共享）           |
|         |                 头部压缩                  |
|         |                服务器推送                 |

**http1.1改进**

1. 缓存处理。在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

   HTTP/1.0中，If-Modified-Since头域使用的是绝对时间戳，精确到秒，但使用绝对时间会带来不同机器上的时钟同步问题。而HTTP/1.1中引入了一个ETag头域用于重激活机制，它的值entity tag可以用来唯一的描述一个资源。请求消息中可以使用If-None-Match头域来匹配资源的entitytag是否有变化。 

   为了使caching机制更加灵活，HTTP/1.1增加了Cache-Control头域（请求消息和响应消息都可使用），它支持一个可扩展的指令子集：例如max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为。

2. 长连接。HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

3. Host头处理。HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

4. 带宽优化及网络连接的使用。HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 

5. 错误通知的管理。在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

**http2.0改进**

1. 二进制分帧

   HTTP/2`引入`二进制数据帧`和`流`的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是`流`所做的事情。

   | 流（`stream`） | 已建立连接上的双向字节流                                     |
   | :------------: | ------------------------------------------------------------ |
   |      消息      | 与逻辑消息对应的完整的一系列数据帧                           |
   |       帧       | `HTTP2.0`通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（`stream id`） |

2. 多路复用。

   1、所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流。

   2、每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。

   举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着stream id用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据stream id将帧再归属到各自不同的请求当中去。

   3、另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。

   4、可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。

3. 服务器推送

   服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。

4. **头部压缩**

   在HTTP1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。

   HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟

## 传输层协议

#### TCP四次挥手过程？第三次挥手客户端收到服务端发来的FIN后处于什么状态（time_wait），为什么要time wait？





# 操作系统

## 线程 进程

### 进程、线程区别

| 进程                                               | 线程                                 |
| -------------------------------------------------- | ------------------------------------ |
| 有独立的地址空间拥有独立的内存单元                 | 没有独立的地址空间，多个线程共享内存 |
| 一个进程崩溃后，在保护模式下不会对其它进程产生影响 | 一个线程死掉就等于整个进程死掉       |
| 一个程序至少有一个进程                             | 一个进程至少有一个线程               |
| 执行开销大，但有利于资源的管理和保护 | 执行开销小，但不利于资源的管理和保护       |
| 一个进程单独的应用 |操作系统并没有将多个线程看做多个独立的应用|

#### 进程切换一定比线程切换开销大吗？



#### 操作系统层面上线程如何同步，语言无关



#### 操作系统用户态和内核态



## 内存

#### 操作系统内存是怎么管理的，虚拟内存是什么？



#### 复制粘贴过程中操作系统做了些什么



# 数据库

## Mysql

### 基础

#### 数据库三范式举例+BCNF范式



#### 数据库的事务隔离级别? 脏读、不可重复读、幻读？



#### sql语句的执行过程，写完一条sql语句之后过程是怎样的？



#### MySQL外键删除策略？



#### MyISAM和InnoDB索引的区别？



#### 什么是事务？事务隔离级别和MVCC？



#### MySQL分库分表的方案？

（我介绍了我们使用的三种方式，hash法、range法以及当前正在使用的hash+range法）



#### 行级锁和表级锁



## 索引

#### MySQL索引有哪些，基于数据结构的分类一下？基于hash和B+树的有什么区别、复杂度？什么时候要建立索引？



#### 索引最左原则，模糊查询一定索引失效?



#### 我现在要看一下索引有没有起作用，请问，我该怎么操作



#### B+树，为什么用B+树，B+树查找历程？索引详细？



#### Where a=xxx and b=xxx and c=xxx，abc都有索引，会如何进行？

## sql优化

#### 怎么加快sql查询？sql优化方法？



#### 跨表查询常见优化思路。



## Redis

#### redis缓存遭到黑客恶意攻击的一些处理方式

# 项目

#### 项目中数据安全性如何保证的？

